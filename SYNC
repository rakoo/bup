The SYNC protocol
=================

This guide aims to detail the internals of the sync protocol introduced
by the sync-cmd command.


Rationale
=========

The bup storage format is an amazingly well-thought format (after all,
it comes from the git people) but there is no way to profit from it
when exchanging information with other machines. The most common
solution is to use rsync to syncrhronise the repo, but it has several
cons:

 - When the repository has few or even no changements, rsync still has to
   go through it all. This is highly problematic with huge repos.
 
 - rsync copies the packs as-is. If the user has decided to repack its
   repo, there will be a change in the packs and the new data will have
   to be transfered, although it already exists on the other machine.

The inherent problem with classical transfer tools is that they are not
aware of bup's data model, which is totally tailored for precise
management of reasonably-sized chunks.

The goal of this protocol is thus to take advantage of bup's storage
format to efficiently transfer data between peers.

A recap of bup's storage format
===============================

Long story short : bup (well, git, really) stores your files as a Merkle
hash tree of blobs, and the protocol sends the changes in the tree.. If
you don't know what Merkle hash trees are, check out your usual sources
of knowledge to have a little background. While you're at it, you should
have in mind how bup splits data (read DESIGN document if you don't) and
how git displays them (check out XXX if you don't)

Ok, now you know what a Merkle hash tree is. Let's see how it is really
implemented in bup. Don't bother verifying the ids, they won't check
out. They are here only for the purpose of the documentation.

Suppose we have the following hierarchy in our filesystem:

  root
   |- dir1
   |   `-littlefile
   `--dir2
       `-bigfile

where littlefile won't get split by bup's algorithm and bigfile will.
So, littlefile will be represented as a single blob and bigfile will be
represented as a _tree_ of (trees of (trees of ...)) blobs:

  040000 tree 93ad197f4840dd90996a68ef023c67b442dff034  00000
  040000 tree 9467cf9a37e65e923e037b3613d95498f37ef34e  035be

This is the `git cat-file -p` format. The first column is the file mode
(here we trick git into thinking we have folders). The second column is
the type. The third column is the id. The fourth column is the folder
name. This example is taken from my real data; notice how the names mean
nothing, although git's documentation says these shoulde be files ? This
is because it isn't really a folder, but the fanout of bup's splitting
algorithm (you have read the DESIGN document, right ?).  So, what we see
here is a representation of our bigfile.

When saving the hierarchy, we will go further up, until we hit the
`root`. We then build a commit containing only one tree, which is the
one holding the `root` hierarchy:

  tree 1234567890123456789012345678901234567890
  author rakoo <rakoo@kpad.otokar.looc2011.eu> 1363722738 +0000
  committer rakoo <rakoo@kpad.otokar.looc2011.eu> 1363722738 +0000

  bup save

  Generated by command:
  ['/usr/lib/bup/cmd/bup-save', '-n', 'example', '.']


If we were to represent bup's representation of the data, it would look
like this : 

  commit1
    `- root
         |- dir1
         |   `-littlefile_as_blob
         `--dir2
             `-a_fake_tree_for_bigfile
                  |- 00000
                  |      |-blob1
                  |      `-blob2
                  `- 035be
                         |-blob3
                         |-blob4
                         |-blob5
                         `-blob6
                      
where `a_fake_tree_for_bigfile` is the representation of bigfile. 

The interesting part comes now. What if we add some data to the repo ?
Here, let's add another bigfile to the repo :

  root
   |- dir1
   |   |-littlefile
   |   `-bigfile2
   `--dir2
       `-bigfile

It turns out, the tree representing our bigfile2 is this one :

  040000 tree 93ad197f4840dd90996a68ef023c67b442dff034  00000
  040000 tree 9467cf9a37e65e923e037b3613d95498f37ef34e  035be
  040000 tree 2496143d2801bda987e290ac88fb49d63e40bdf7  172b4

Notice something familiar ? Yes, exactly : the first 2 lines are
_exactly_ the trees composing bigfile ! Running bup save on the repo
will give us a new commit, with the following structure : 

  commit2
    `- root
         |- dir1
         |   `-littlefile_as_blob
         `--dir2
             |-a_fake_tree_for_bigfile
             |    |- 00000
             |    |    |-blob1
             |    |    `-blob2
             |    `- 035be
             |         |-blob3
             |         |-blob4
             |         |-blob5
             |         `-blob6
             `-another_fake_tree_for_bigfile2
                  |- 00000
                  |    |-blob1
                  |    `-blob2
                  |- 035be
                  |    |-blob3
                  |    |-blob4
                  |    |-blob5
                  |    `-blob6
                  `- 172b4
                       |-blob7
                       `-blob8

where another_fake_tree represents bigfile2. It is important to notice
here that :

  - `dir1` and `littlefile_as_blob` are represented by the same id as before
    (they haven't changed)

  - same thing for `a_fake_tree_for_bigfile` (bigfile hasn't changed)

  - `another_fake_tree_for_bigfile2` is a new file, so it is represented by a new id

  - because `dir2` has changed, it has a new id, along with its parents
    until the top : `root` has a new id, and `commit2` is new.

The syncing protocol
====================

You are supposed to have read the previous paragraph here.

Let's suppose I have two machines, A and B. A has the content described
as in commit1, and shares it (by any means, say scp) to machine B. Both
now have a complete description of commit1 (along with the actual data,
of course). Suppose now that the situation happening in commit2 was
done on A (ie I just `bup-save`d new content on A), and I want to
transmit it to B. This is the goal of the syncing algorithm, of course.
The syncing protocol works as following for the situation described
before:

  1. What (git) refs do A and B and have ? Each sends them to the other
     side, along with the commit-id they point to.

  2. Among the refs a peer receives, check the ones it doesn't have. In
     the situation described before, B wants commit2 and A wants
     nothing. B says it to A.

  3. A starts by sending the full content of commit2.

  4. B receives commit2 and reads it. It sees that there is a root with
     some new id, so asks it from A, which sends it to B.

  5. B receives the `root` tree. It sees that there is a `dir1` it
     already knows, and a `dir2` it doesn't. It asks A to send it.

  6. B receives `dir2`, sees there is `a_fake_tree` it already knows and
     `another_fake_tree` it doesn't. It asks A to send it.

  7. B receives `another_fake_tree`. It sees there is `a_fake_sub_tree`
     and `another_fake_sub_tree` it already knows so it skips them. It
     asks A for `yet_another_fake_sub_tree`.

  8. B receives `yet_another_fake_sub_tree`. It contains 2 blobs B has
     never heard about, so it asks A to send them.

  9. B receives `blob7` and `blob8`. It can validate the tree up to
     `commit2` and decide if the transfer is valid.


This protocol is really simple but ensures that the communication will
be really small : notice that there is very very few information
exchanged that isn't actual data. I hope you realize that what's
exchanged is only the diff between commits, not extraneous data. 

This protocol is pull-driven : B wants new data, so it asks A to send
it. A doesn't store any state about who wants what or who asked for
what or whatever; it will always be B who checks what it has, what it
has received and what it still lacks.

Messages
========

The whole communication happens with HTTP-like messages.

Framing
-------

All messages are framed to quickly be able to skip through messages and
(lightly)verify there was no mangling.

Each message is preceded by its byte-length in network order on 4 bytes,
and followed by a null byte. The resulting total frame is preceded of
its length in network order on 4 bytes.

Here is an example of a full frame of 2 fictional messages, "Hello" and
"World!":

  ```
  00230005Hello\00006World!\0
  ```

SHA1 IDS
--------

bup deals a lot with SHA1 ids. There are some difficulties in using them,
because they are hard to display in pure binary mode.

The rule for the sync protocol is simple : ALL sha1 ids are in binary,
no exception.




There are 4 on-the-wire messages exchanged : CAPA, REFS, WANT, HAVE

CAPA message
------------

CAPA messages are used to indicate the capacities of a peer. As of today
(2013-03-22), there are only 2 capabilities :

  - PUSH indicates that a peer is ok to push data it is asked to send
  - PULL indicates that a peer is ok to pull data it needs

Format, for a PUSH and PULL peer:

  ```
  CAPA\n
  PUSH\n
  PULL
  ```

Format for a PUSH only peer:

  ```
  CAPA\n
  PUSH\n
  ```

Note that CAPA messages are used as handshake messages.

REFS message
------------

REFS messages are used to exchange the list of git refs a peer has.

Format:

  ```
  REFS\n
  refname1 <sha1 id>\n
  refname2 <sha1 id>
  ```

Be careful that the ids are in binary ! 

WANT message
------------

A WANT message is sent to a peer to indicate we want it to send some
data.

Format:

  ```
  WANT <sha1 id>
  ```

One WANT message only conveys information for 1 id. If you want to ask
for multiple ids, you have to use multiple WANT messages.

HAVE message
------------

A message to exchange the actual data.

Format:

  ```
  HAVE <sha1 id> <type>\n
  <content>
  ```

where type is the type of the content. It can either be `commit`, `tree`
or `blob`.

One HAVE message only conveys information for 1 id. If you want to send
multiple ids, you have to use multiple HAVE messages.

Remarks, thoughts and possible improvements
===========================================

This protocol is designed to be extensible. You can tell by the
HTTP-like messages. However it isn't really consistent : 

  - The cmds (CAPA, REFS, WANT, HAVE) are hardcoded to be limited to 4
    bytes. This was used in first versions because it was easier to
    parse, but should be removed.

  - some messages (CAPA and REFS) don't have anything else on the same
    line, but others (WANT and HAVE) encode a lot of thing on the first
    line. They shouldn't.

This protocol was inspired by how PPSP (Peer to Peer Streaming Protocol)
and its main implementation libswift [0] works, which is basically a
way to exchange big data indexed by a merkle hash tree. I just took it
and added the knowledge of each node to take further decision. Big
thanks to their clear, open specifications.

In the beginning of the designing of this protocol, I intended it to be
very much ppsp-like, with some process listening on an UDP socket for
incoming messages, which can come in any order. I have instead resorted
to using TCP sockets. However I have kept the atomicity in the WANT
message, and thus you have to send 1 WANT message per id requested. An
easy improvement could be to group them all in one WANT message.

There is no security built inside the protocol. If you want to encrypt
your data floating around, you should consider creating an SSH tunnel.
You can do so by using the -L flag :

  A> ssh -L 8000:B:8000

and connect to localhost:8000 instead of B:8000.

The biggest disadvantage of this protocol is that there is no way to
predict exactly how much data will be sent. We could do a diff on the
sending side to list all the chunks we have to send, but :

  - it needs a lot of calculation, and might not be doable if the sender
    is used by a lot of peers

  - it doesn't take into account the fact that B may have some other
    chunks that he hasn't advertised in the REFS message, but still has
    so won't ask during the exchange.

We could still do it in parallel of the exchange (ie not blocking the
beginning of transfer) along the transfer, though.

[0] libswift.org
